#### 링크
https://silk-vanilla-48e.notion.site/4-242f22fbe5c1803ba0fcfd015f3024f6

# 4. 역할, 책임, 협력

- 중요한 것은 개별 객체가 아니라 객체들 사이에 이뤄지는 협력이다.
- 객체지향 설계의 전체적인 품질을 결정하는 것은 개별 객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 협력의 품질이다.
- 훌륭한 객체지향 설계란 겉모습은 아름답지만 협력자들을 무시하는 오만한 객체를 창조하는 것이 아니라 **조화를 이루며 적극적으로 상호작용하는 협력적인 객체를 창조하는 것이다**
- 어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다.
- 객체지향 설계의 품질을 결정하는 역할 책임 협력의 개념에 관해 살펴볼 것이다. 그 후 협력이 어떤 식으로 객체의 외양과 특성을 결정하는지 설명한다.

## **협력**

---

- 협력은 한 사람이 다른 사람에게 도움을 요청할 때 시작된다.
- **협력은 다수의 요청과 응답으로 구성되며** 전체적으로 **다수의 연쇄적인 요청과 응답의 흐름으로 구성된다.**
- 객체가 협력에 참여하기 위해 필요한 데이터와 행동이 어느 정도 결정된 후에 클래스의 구현 방법을 결정해야 한다.
- 협력 관계 안에서 특정 요청을 받아들일 수 있는 이유는 **그 요청에 대해 적절한 방식으로 응답하는 데 필요한 지식과 행동 방식을 가지고 있기 때문이다.**
- 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.

## **책임**

---

> “객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것” - 크레이그 라만
> 
- 책임을 어떻게 구현할 것인가 하는 문제는 객체와 책임이 제자리를 잡은 후에 고려해도 늦지 않다.
- 객체와 책임이 이리저리 부유하는 상황에서 성급하게 구현에 뛰어드는 것은 변경에 취약하고 다양한 협력에 참여할 수 없는 비자율적인 객체를 낳게 된다.

### **책임의 분류**

- 크레이그 라만은 객체의 책임을 두 가지 범주로 자세히 분류하고 있다.
    - **하는 것(doing)**
        - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
        - 다른 객체의 행동을 시작시키는 것
        - 다른 객체의 활동을 제어하고 조절하는 것
    - **아는 것(knowing)**
        - 개인적인 정보에 관해 아는 것
        - 관련된 객체에 관해 아는 것
        - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

<aside>
💡

왕은 재판 집행이라는 책임을 수행하기 위해 재판의 참여하는 다른 객체들의 활동을 제어하고 조율하고 있다 따라서 왕은 하는 것과 관련된 책임을 수행한다.

하얀 토끼는 목격자가 모자 장수라는 사실을 알고있으며 관련된 객체에 관해 아는 것이란 책임을 가지며, 다른 객체의 행동을 시작하는 두 번째 책임도 가지므로 아는 것과 하는 것의 두 가지 종류의 책임을 모두 수행한다

</aside>

- 객체의 책임을 이야기할 때는 일반적으로 외부에서 접근 가능한 공용 서비스의 관점에서 이야기 한다.
    - 즉, 책임은 객체의 외부에 제공해 줄 수 있는 정보와(아는 것) 외부에 제공해줄 수 있는 서비스(하는 것의 측면)의 목록이.
    - 따라서 책임은 객체의 공용 인터페이스(public interface)를 구성한다.

### **책임과 메시지**

- 책임이 협력이라는 문맥 속에서 요청을 수신하는 한 쪽의 객체 관점에서 무엇을 할 수 있는지를 나열하는 것이라면 메시지는 협력에 참여하는 두 객체 사이의 관계를 강조한 것이다.
- 두 객체가 서로 협력할 수 있는 것은 객체 A는 **객체 B가 이해할 수 있는 메시지를 전송**할 수 있고, 객체 B는 **객체 A가 전송하는 메시지에 대해 적절한 책임을 수행**할 수 있기 때문이다.
- **책임과 메시지의 수준은 다르다**
    - 책임이 보다 더 상위 수준의 개략적인 개념
    - 하나의 책임은 일반적으로 여러 메시지로 분할된다
- **책임과 협력(메시지)의 구조**가 완성되기 전엔 책임을 어떻게 구현할지에 대한 고민은 미뤄두는 것이 좋다
    1. **어떤 책임을 수행**해야 하고
    2. **어떤 객체로부터 어떤 메시지를 수신**할 것인지를 결정하는 것으로 부터 객체지향 설계가 시작된다
    

## **역할**

---

- 어떤 객체가 수행하는 **책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다.**
- 역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부하를 줄일 수 있다.
- 역할은 객체지향 설계의 **단순성**(simplicity), **유연성**(flexibility), **재사용성**(reusability)을 뒷받침하는 핵심 개념이다.

### **협력의 추상화**

- **역할의 가장 큰 가치는** 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 **협력을 추상화할 수 있다는 것이다.**
- 구체적인 객체로 추상적인 역할을 대체해서 **동일한 구조의 협력을 다양한 문맥에서 재사용할 수 있는 능력은 과거의 전통적인 패러다임과 구분되는 객체지향만의 힘이다.**

### **대체 가능성**

- 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다.
- 따라서 대부분의 경우에 객체의 타입과 역할 사이에는 **일반화/특수화 관계가 성립하는 것이 일반적이다.**

## **객체의 모양을 결정하는 협력**

---

### 흔한 오류

1. **데이터를 저장하기 위해 객체가 존재한다는 선입견**
2. **클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다는 오류**

> 데이터는 단지 객체가 행위를 수행하는 데 필요한 재료일 뿐이다. 객체가 존재하는 이유는 행위(책임)를 수행하며 협력에 참여하기 위해서다.
> 
- 애플리케이션을 설계할 땐 각 객체를 독립적으로 바라보지 말고, **협력이라는 문맥**을 고려해야 함
    - 실제로 동작하는 애플리케이션을 구축하기 위해선 **해당 객체가 참여하는 협력**을 우선적으로 고려해야 함
    - 협력을 배제한 상태에서 **어떤 데이터가 필요하고 어떤 클래스로 구현해야 하는지 고민하는 것**은 아무런 도움이 되지 않는다

### **협력을 따라 흐르는 객체의 책임**

- 먼저, 견고하고 깔끔한 **협력을 설계**할 것
    - 협력 설계 -> **객체들이 주고받을 요청과 응답의 흐름을 결정**하는 것을 의미
    - 이 흐름은 **객체들이 수행할 책임**이 된다

### **⭐️ 아래 순서로 객체 설계를 진행하기 (p.129)**

- 협력 설계 -> 책임(외부에 제공할 행동) 할당 -> 필요한 데이터 결정 -> 클래스 구현 방법 결정
- 책임 결정 및 할당 과정이 얼마나 합리적이고 적절하게 수행되었는지가 설계의 품질을 결정

> **객체지향 시스템에서 가장 중요한 것은 충분히 자율적인 동시에 충분히 협력적인 객체를 창조하는 것이다. 이 목표를 달성할 수 있는 가장 쉬운 방법은 객체를 충분히 협력적으로 만든 후에 협력이라는 문맥 안에서 객체를 충분히 자율적으로 만드는 것이다. (p.130)**
> 

## **객체지향 설계 기법**

---

### **책임-주도 설계(Responsibility-Driven Design)**

- 객체지향 시스템의 목적은 사용자의 요구를 만족시킬 수 있는 기능을 제공하는 동시에 이해하기 쉽고, 단순하며, 유연한 상호작용을 제공하는 객체들의 공동체를 구축하는 것이다.
- 시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당된다.
- 만약 책임을 여러 종류의 객체가 수행할 수 있다면 협력자는 객체가 아니라 추상적인 역할로 대체된다.

### **객체지향 시스템을 설계하는 절차**

- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

### **디자인 패턴**

- 패턴은 해결하려고 하는 문제가 무엇인지를 명확하게 서술하고, 패턴을 적용할 수 있는 상황과 적용할 수 없는 상황을 함께 설명한다.
- 패턴은 반복해서 일어나는 특정한 상황에서 어떤 설계가 왜(why) 더 효과적인지에 대한 이유를 설명한다.

### **테스트-주도 개발**

- 테스트-주도 개발은 테스트를 작성하는 것이 아니라 **책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.**
- 테스트-주도 개발은 다양한 설계 결험과 패턴에 대한 지식이 없는 사람들의 경우에는 온전한 혜택을 누리기가 어렵다
- 테스트-주도 개발은 책임-주도 설계의 기본 개념과 다양한 원칙과 연습, 패턴을 종합적으로 이해하고 좋은 설계에 대한 감각과 경험을 길러야만 적용할 수 있는 설계기법이다.

## 회고

- **평소 설계할 때 데이터를 중점적으로 혹은 우선적으로 설계했던 경험과 관계에서 정적인 측면을 고려했던 경험을 회고할 수 있었음**
    - 이는 역할을 분명하게 생각하지 않고 구현했기 때문에 특정 기능에 대해 객체들의 협력 관계에서 좋은 설계를 고민하기 어렵지 않았나라는 생각을 하게 만들었음
    - 어떤 기능을 수행하기 위한 명세(협력 명세)를 분명하게 하고 그 안에서 객체의 책임을 식별하는 경험을 해보고 싶음
- **TDD 에 관한 설명에 공감을 함 TDD는 테스트에 초점을 맞추면 오히려 의미없는 테스트를 생성했던 기억이 있음 → 클라이언트 입장에서 해당 객체에 원하는 동작(책임)을 생각하고 테스트를 작성하면 유지보수 하기 쉬웠던거 같음**
