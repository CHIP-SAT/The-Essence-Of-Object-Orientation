### 링크

https://silk-vanilla-48e.notion.site/7-253f22fbe5c180f39824e2070ac22553?pvs=74

## 서론

---

- 마틴 파울러 왈
    - 객체지향 설계 안에 조냊하는 세 가지 상호 연관된 관점에 관해 설명한다.
    - 개념 관점, 명세 관점, 구현 관점
- **개념 관점**
    - **도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.**
    - 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다.
    - 이 관점은 사용자가 도메인을 바라보는 관점을 반영한다.
    - 따라서 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다.
- **명세 관점**
    - 개념에서 소프트웨어로 전환되는 관점으로 소프트웨어 안에 **객체들의 책임에 초점**을 맞춘다.
    - 명세 관점에서 프로그래머는 객체가 협력을 위해 **‘무엇’**을 할 수 있는가에 초점을 맞춘다.
    - 무엇에 초점을 맞춘다는 것은 인터페이스를 바라본다는 뜻이고 **인터페이스에 대해 프로그래밍**하는 것이다(세부 구현은 나중으로)
- **구현 관점**
    - 실제 작업을 수행하는 코드와 연관돼 있다.
    - 구현 관점의 초점은 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것
    - 프로그래머는 이 과점에서 객체의 책임을 **‘어떻게’** 수행할 것인가에 초점을 맞춘다.

### 세 가지 관점은 순서대로 수행해야하나?

- **세 개의 관점은 순서대로 수행되어야 함을 의미하지 않는다**
    - **하나의 클래스를 세 가지 다른 방향에서 바라보는 것을 의미한다.**
- **클래스의 세 가지 관점**
    - 클래스가 은유하는 개념은 도메인 관점을 반영한다.
    - 클래스의 공용 인터페이스는 명세 관점을 반영한다.
    - 클래스의 속성과 메서드는 구현 관점을 반영한다.

클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다.

동시에 코드 안에서 세 가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야 한다.

## 커피 전문점 도메인

---

### 커피 주문

![image.png](attachment:a8fda0e7-c14a-4e77-9eaf-298dbb7a84ea:image.png)

### 커피 전문점이라는 세상

- **상태와 무관하게 동일하게 해동할 수 있는 객체들은 동일한 타입의 인스턴스로 분류할 수 있다.**
    - 손님, 메뉴판, 메뉴 항목, 바리스타, 커피…..
- 개념 사이의 관계
    - 하나의 메뉴판 객체는 다수의 메뉴 항목 객체로 구성돼 있으며 **메뉴판과 메뉴 항목 객체는 따로 떨어져 존재하지 않으며 하나의 단위로 움직인다.**
        - 이런 관점에서 메뉴 항목 객체가 메뉴판 객체에 포함돼 있다고 할 수 있는데 이를 메뉴판 타입과 메뉴 항목 타입 간**의 합성 관계로 단순화하면** 좀 더 보기 수월할 것이다.
    - 손님 또한 메뉴판을 알고 있어야 원하는 커피를 선택할 수 있어서 관계를 가지는데 메뉴판 타입은 손님의 일부가 아니므로 이 관계는 합성 관계가 아니다.
        - 이처럼 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 할 경우 **이를 연관(association) 관계**라고 한다.
        - 손님과 바리스타 그리고 바리스타와 커피 관계도 이와 동일하다.

![image.png](attachment:851e6683-9d16-48dc-9a6f-cd54b2451760:image.png)

- 위는 커피 전문점의 도메인 모델이다.
    - 도메인 모델이란 도메인을 단순화해서 표현한 모델이다.

## 설계하고 구현하기

---

### 커피를 주문하기 위한 협력 찾기

- 객체지향 설계의 첫 번째 목표는 훌륭한 객체를 설계하는 것이 아니라 훌륭한 협력을 설계하는 것이라는 점을 잊지 말자
- 훌륭한 객체는 훌륭한 협력을 설계할 때만 얻을 수 있다.
- 협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.
    
    ![image.png](attachment:fab52081-1a4b-4011-9c30-7cf4f4550ecf:image.png)
    
- 현재 설계할 협력은 커피를 주문하는 것이다.
    - **첫번째 메시지는** 커피를 주문하라 일것이다.
        - 메시지에는 메시지에 담아 전달될 부가적인 정보인 인자도 작성할 수 있다.
    - 메시지를 찾았으니 이제 **메시지를 처리하기 적합한 객체를 선택해야 한다.**
        - **소프트웨어 객체는 현실 객체의 은유다 어떤 객체를 은유해야 하는가?**
        - 우리는 커피 전문점을 추상화한 도메인 모델이라는 훌륭한 재료를 가지고 있다.
        - 우리 메시지를 처리할 적절한 ‘타입’ 을 찾아라
        - 당연히 손님일 것이다.
    - 손님은 주문하라라는 책임이 부여됐고 커피 메뉴를 알 수 없으니 **책임을 수행하기 위해 다른 객체에게 메뉴 항목을 찾을 메시지를 보내야 한다.**
        - 메뉴판일 것이다.
    - 항목을 찾은 손님은 이제 커피를 제조해야하는 책임을 처리할 수 없으니 다른 객체에게 메시지를 보낼 것이다.
        - 바리스타일 것이다.
    - **바리스타와 메뉴판을 고른 이유는 해당 메시지를 처리할 수 있는 가장 많은 정보를 가지고 있어서 이다.**

협력에 필요한 객체의 종류와 책임, 주고 받아야 하는 메시지에 대한 대략적인 윤곽이 잡혔다. 남은 일은 메시지를 정제함으로써 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제하는 것이다. 

### 인터페이스 정리하기

- 우리가 지금까지 얻어낸 것은 객체들의 인터페이스이다.
    - 객체가 수신한 메시지가 객체의 인터페이스를 결정한다는 사실을 기억하라
    - 메시지가 객체를 선택했고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들인다.
- 각 객체를 협력이라는 문맥에서 떼어내어 수신 가능한 메시지만 추려내면 객체의 인터페이스가 된다.
- 객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재한다는 것을 의미한다.

<aside>
💡

타입 == 인터페이스

책에서 인터페이스와 타입이라는 말을 자주 사용하는데 처음에는 인터페이스를 언어 문법의 인터페이스로 인식했으나

저자의 글을 읽다보니 정확히는 객체 외부에서 제공되는 public 오퍼레이션을 의미하는 것 같다.

더 나아가 책에서 객체의 타입을 메시지를 통해서 정의하고 그 후에 객체를 정한다고 말한다.

그러면서 정적인 타입을 설계했다는 식으로 말하며 외부에서 제공하는 오퍼레이션이 같은 객체는 같은 타입이라고 정의한다.

따라서 저자가 말하는 타입과 인터페이스는 같은 의미로 봐도 무방할 것 같다(개인적인 생각 )

</aside>

### 구현하기

- 지금까지는 객체의 타입, 객체가 외부에서 제공할 메서드 **즉 수신할 메시지에 대해서 정의만해왔다**
- 구현하기 단계에서는 **어떻게 다른 객체와 협력할 것이며, 어떻게 책임을 수행할 것인지를 코드로 정의한다.**
- **설계는 구현단계에서 수정하지 못하나요?**
    - **구현하면서 설계 작업때 진행했던 스케치는 언제든지 변경될 수 있다.**
- **구현 단계에서 속성을 정의하라**
    - 구현하기 전까지는 어느 객체 타입에 속성을 넣을지는 정의하지 않고 설계했다는 사실에 주목하자
    - 인터페이스를 설계할 때는 내부 속성의 목록, 타입, 자료구조를 고려하지 않는다
- **설계는 빠르게 하여 구현에 집중하자**
    - 설계는 중요하지만 설계만으로 구현의 코드를 온전히 설계할 수 없다.
    - 항상 설계는 구현 도중에 변경되므로 설계는 간단하고 빠르게 하고 구현에 집중하도록 하자
    - TDD를 구현하는 사람들은 이러한 작업을 테스트 코드를 작성해 가면서 협력을 설계한다.

## 코드의 세 가지 관점

---

### 코드와 세 가지 관점

**개념 관점에서** 코드를 바라보면 각 객체에 해당하는 클래스들이 있는데 이 클래스들은 **도메인 개념의 특성을** **최대한 비슷하게 해서 변경이 발생해도 관리가 쉽고 유지보수를 쉽게 만들 수 있다**

**명세 관점**은 인터페이스를 바라보는데 외부 객체가 특정 객체에 접근하는 공용 인터페이스를 수정하면 해당 객체와 협력하는 모든 객체에게 영향이 갈 수밖에 없다. **그래서 객체들의 인터페이스를 수정하기 어렵기 때문에 처음 설계할 때 구현과 관련된 세부 사항이 드러나지 않게 만들자**

**구현 관점은** 클래스의 내부를 바라본다. 클래스의 메서드와 속성은 외부에서 보이지 않으며 **이들이 변경되어도 외부에 영향을 미쳐서는 안된다**

### 인터페이스와 구현을 분리하라

**명세 관점은 클래스의 안정적인 측면을 드러내고 구현 관점은 클래스의 불안정한 측면을 드러내야 한다. 인터페이스에 구현 세부 사항을 노출하지 말자**
