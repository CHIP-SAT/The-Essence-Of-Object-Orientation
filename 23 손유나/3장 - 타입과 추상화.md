### 추상화를 통한 복잡성 극복

- 현실은 복잡하며 예측 불가능한 혼돈의 덩어리임.
- 따라서 사람들은 본능적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화하는 전략을 따름.
- **추상화의 정의**
    - 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
    - 복잡성을 다루기 위해 추상화는 두 차원에서 이루어짐
        1. 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만듦
        2. 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만듦
    - 훌륭한 추상화는 목적에 부합해야 함.
- 객체지향 패러다임은 **객체**라는 추상화를 통해 현실의 복잡성을 극복함.

---

### 객체지향과 추상화

- **객체지향 패러다임에서의 객체**
    - 명확한 경계를 가지고 서로 구별할 수 있는 구체적인 사람이나 사물
- 객체지향 패러다임의 중심에는 구체적이고 실제적인 객체가 존재하지만 수많은 객체들을 개별적인 단위로 취급하기에는 인간의 인지능력이 턱없이 부족함.
- 따라서 공통적인 특성을 기준으로 객체를 여러 그룹으로 묶어 동시에 다뤄야 하는 가짓수를 줄임으로써 상황을 단순화함.
- **개념이란?**
    - 공통점을 기반으로 객체들을 묶기 위한 그릇
    - 특정한 객체가 어떤 그룹에 속할 것인지를 결정
    - ex) 길거리를 빠른 속도로 누비는 교통 수단 → 자동차
    - ex) 하늘을 나는 교통수단 → 비행기
- 개념을 이용하면 객체를 여러 그룹으로 **분류**할 수 있음.
- 개념의 인스턴스
    - 개념이 객체에 적용됐을 때의 객체
- **개념의 3가지 관점**
    - **심볼** : 개념을 가리키는 이름
        - ex) 트럼프
    - **내연** : 개념의 의미
        - 개념을 객체에게 적용할 수 있는지 여부를 판단하기 위한 조건
        - ex) 몸이 납작하고 두 손과 두 발은 네모 귀퉁이에 달려 있는 등장인물
    - **외연** : 개념의 인스턴스들이 모여 이뤄진 집합
        - ex) 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트 왕과 하트 여왕

---

### 객체를 분류하기 위한 틀

- **분류란?**
    - 객체에 특정한 개념을 적용하는 작업
    - 객체에 특정한 개념을 적용했다는 것은 그 객체를 특정한 집합의 멤버로 분류하고 있다는 것
- 어떤 객체를 어떤 개념으로 분류할지가 **객체지향의 품질**을 결정

---

### 분류는 추상화를 위한 도구다

- 개념을 통해 객체를 분류하는 과정은 추상화의 2가지 차원을 모두 사용함.
- 앨리스 예시
    - 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트 왕과 하트 여왕을 트럼프라는 개념으로 묶음. ⇒ 개별 객체 간의 차이점은 무시하고 공통점을 취한 결과
    
    ⇒ **추상화의 첫 번째 차원인 일반화를 적용한 결과**
    
    - 트럼프에 속하는 객체들의 공통점 중에서도 우리가 중요하다고 생각하는 특징은 몸이 납작하고 두 손과 두 발이 네모난 몸 모서리에 달려 있다는 것 뿐
    
    ⇒ **추상화의 두 번째 차원에 따라 불필요한 세부 사항을 제거**

---

### 타입

- **타입이란?**
    - 공통점을 기반으로 객체들을 묶기 위한 틀 (개념과 동일)
- 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 하고, 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 됨.
- **타입이 없다는 말의 의미**
    - 메모리 안의 데이터를 다룰 수 있는 단 하나의 타입만 존재한다는 것
    - 타입이 없는 체계 안에서 모든 데이터는 일련의 비트열로 구성됨
- 어떤 메모리 조각에 들어 있는 값의 의미는 **외부의 해석가**(애플리케이션)에 의해 결정됨.
- **타입 시스템의 목적**
    - 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하는 것
- 타입 시스템은 메모리 안에 저장된 0과 1에 대해 수행 가능한 작업과 불가능한 작업을 구분함으로써 데이터가 잘못 사용되는 것을 방지함.
- **타입의 2가지 중요한 사실**
    1. 타입은 데이터가 어떻게 사용되느냐에 관한 것
        - 데이터가 어떤 타입에 속하는지를 결정하는 것은 데이터에 적용할 수 있는 작업
        - 연산자 : 데이터를 이용해 수행할 수 있는 작업
            - 연산자의 종류가 아니라 어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 그 데이터의 타입을 결정함.
    2. 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰짐.
        - 개발자는 오직 해당 데이터 타입을 사용하기 위해 데이터 타입에 적용할 수 있는 연산자만 알고있으면 됨.

---

### 객체와 타입

- 객체는 데이터가 아님.
    - 객체를 장조할 때 가장 중요하게 고려해야 하는 것은 객체가 이웃하는 객체와 협력하기 위해 어떤 행동을 해야 할지를 결정하는 것
- 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 **객체가 수행하는 행동**임
    - 객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동한다면 그 객체들은 동일한 타입에 속함.
    - 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있음
        - 동일한 행동 == 동일한 책임 == 동일한 메시지 수신
        - 다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없음. ⇒ 다형성
    - 데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미 ⇒ 캡슐화
    - 책임-주도 설계라고 부르는 객체지향 설계 방법은 데이터를 먼저 생각하는 데이터-주도 설계 방법의단점을 개선하기 위해 고안됨.
- 객체의 내부적인 표현은 외부로부터 철저하게 감춰짐.
    - 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방함.
- 객체를 객체답게 만드는 가장 핵심적인 원칙
    - 객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다.

---

### 타입의 계층

- 객체가 동일한 타입으로 분류되기 위해서는 공통의 행동을 가져야만 함.
- 앨리스 예시
    - 트럼프 → 트럼프 인간 (X)
    - 트럼프 인간 → 트럼프 (O)
- **일반화/특수화 관계**
    - 타입과 타입 사이에는 일반화/특수화 관계가 존재할 수 있고, 일반화와 특수화는 동시에 일어남.
    - 더 특수하다는 것은 일반적인 개념보다 범위가 더 좁다는 것을 의미
- 객체지향에서 일반화/특수화 관계를 결정하는 것은 **행동**
    - 두 타입 간에 일반화/특수화 관계가 성립하려면, 한 타입이 다른 타입보다 더 특수하게 행동해야 하고 반대로 한 타입은 다른 타입보다 더 일반적으로 행동해야 함.
- **행동의 관점에서 더 일반적인 타입과 특수한 타입**
    - 일반적인 타입 : 특수한 타입이 가진 모든 행동들 중에서 일부 행동만을 가지는 타입
    - 특수한 타입 : 일반적인 타입이 가진 모든 타입을 포함하지만 거기에 더해 자신만의 행동을 추가하는 타입
- 정리하면, 일반적인 타입은 특수한 타입에 비해 더 적은 수의 행동을 가지며, 특수한 타입은 일반적인 타입에 비해 더 많은 행동을 가진다.
- 주의해야할 점
    - 타입의 내연을 의미하는 행동의 가짓수와 외연을 의미하는 집합의 크기는 서로 반대임
        - 일반적인 타입은 특수한 타입보다 외연은 크지만 내연은 작음

---

### 슈퍼타입과 서브타입

- 일반적인 타입 → 슈퍼타입
- 특수한 타입 → 서브타입
- 일반적으로 서브타입은 슈퍼타입의 행위와 호환되기 때문에 서브타입은 슈퍼타입을 대체할 수 있어야 함.
- 서브 타입은 슈퍼타입의 행위에 추가적으로 특수한 자신만의 행동을 추가하는 것이므로 슈퍼타입의 행동은 서브타입에게 자동으로 상속됨.

---

### 정적 모델

- 타입을 사용하면 동적으로 변하는 객체의 상태를 정적인 관점에서 표현 가능
- 이런 관점에서 결국 타입은 추상화임.
- **동적 모델과 정적 모델**
    - 객체를 생각할 때 2가지 모델을 동시에 고려함.
        - 객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐 (= 객체의 스냅샷, 동적 모델)
        - 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현 (= 타입 모델, 정적 모델)

---

### 클래스

- 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현됨.
- 따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것임.
- 클래스 ≠ 타입
    - 클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일 뿐
