### 객체지향 패러다임의 목적

- 현실 세계를 모방하는 것이 아닌, 현실 세계를 기반으로 **새로운 세계**를 창조하는 것

---

### 객체의 정의

- 식별 가능한 개체 또는 사물
- 자동차처럼 만질 수 있는 **구체적인 사물**일 수도 있고, 시간처럼 **추상적인 개념**일 수도 있음.
- 구별 가능한 **식별자**, 특징적인 **행동**, 변경 가능한 **상태**를 가짐.

---

### 상태가 필요한 이유

- 일반적으로 과거에 발생한 행동의 이력을 통해 현재 발생한 행동의 결과를 판단하는 방식은 복잡하고 번거로움. → 따라서 행동의 **과정**과 **결과**를 단순하게 기술하기 위해 **상태**라는 개념을 고안함.
- ex) 비행기 탑승 가능 여부 → 항공권의 발권 상태
- 상태를 이용하면 과거의 모든 행동 이력을 설명하지 않고도 **행동의 결과를 쉽게 예측하고 설명 가능**
    - ex) 엘리스의 키와 문의 높이 상태만 알면, 문을 통과하는 행동의 결과를 예측 가능

---

### 상태와 프로퍼티

- 세상에 존재하는 모든 것들이 객체인 것은 아님.
    - 숫자, 문자열, 양, 속도, 시간, 날짜, 참/거짓과 같은 단순한 값들은 객체가 아닌, **다른 객체의 상태를 표현**하기 위해 사용됨.
- **프로퍼티** : 객체의 상태를 구성하는 모든 특징
    - 프로퍼티 : 정적
    - 프로퍼티 값 : 동적
- **링크** : 객체와 객체 사이의 의미 있는 연결
    - 링크가 존재해야만 객체는 서로 **요청**을 주고 받을 수 있음.
    - 링크는 **객체가 다른 객체를 참조할 수 있다는 것을 의미**
- **속성** : 객체를 구성하는 단순한 값

---

### 객체의 상태 정의

- 특정 시점에 객체가 가지고 있는 정보의 집합
- 객체의 **구조적 특징**을 표현
- 객체에 존재하는 정적인 **프로퍼티**와 동적인 **프로퍼티 값**으로 구성
- **객체의 프로퍼티**
    - **속성**과 **링크**로 구분

---

### 행동

- 객체는 다른 객체의 상태에 직접적으로 접근하거나 상태를 변경할 수 없음 ⇒ **간접적**으로 객체의 상태를 변경하거나 조회할 수 있는 방법이 필요 ⇒ **행동**
- 행동은 다른 객체로 하여금 **간접적으로 객체의 상태를 변경하는 것을 가능하게 함.**
- 객체의 상태는 **객체의 자발적인 행동에 의해서만 변경**됨.
    - 객체의 행동에 의해 객체의 상태가 변경된다는 것 == 행동이 **부수 효과**를 초래한다는 것
- **상태와 행동 사이의 관계**
    - 객체의 행동은 상태에 영향을 받는다.
    - 객체의 행동은 상태를 변화시킨다.

---

### 협력과 행동

- 객체가 다른 객체와 협력하는 유일한 방법은 **다른 객체에게 요청을 보내는 것**
- **객체의 행동으로 인해 발생하는 결과**
    - 자기 자신의 상태 변경
    - 행동 내에서 협력하는 다른 객체의 상태 변경 유발(메시지 전송)

---

### 행동의 정의

- 외부의 요청 또는 수신된 메시지에 **응답**하기 위해 동작하고 반응하는 활동
- 행동의 결과로, 객체는 **자신의 상태를 변경**하거나 **다른 객체에게 메시지를 전달**할 수 있어야 함.
- 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 **외부에 가시적**이어야 함.

---

### 상태 캡슐화

- 객체지향 세계에서 모든 객체는 **자신의 상태를 스스로 관리**하는 자율적인 존재임
    - 앨리스 객체의 키를 작게 만드는 것은 앨리스 자신, 음료 객체의 양을 줄이는 것은 음료 자신
    - 앨리스가 음료를 마시는 행동
        - 앨리스 자신의 키를 작게 만듦.
        - 앨리스가 자신이 먹은 양만큼 음료의 양을 줄여달라고 메시지를 전송
- 메시지를 앨리스에게 전송하는 객체이건, 음료에게 메시지를 전송하는 앨리스 객체이건 메시지 송신자는 메시지 수신자의 상태 변경에 대해 전혀 알지 못함. ⇒ **캡슐화**
- 외부에서 객체에 접근할 수 있는 유일한 방법과 객체가 외부에 노출하는 것은 **행동**뿐임.
- **상태를 캡슐화해야 하는 이유**
    - 상태를 외부에 노출시키지 않고 행동을 경계로 캡슐화하는 것은 객체의 **자율성**을 높이고, 객체의 자율성이 높아질수록 **객체의 지능이 높아져** **협력을 단순하고 유연한게 만들기 때문**

---

### 식별자

- 객체를 서로 구별할 수 있는 특정한 프로퍼티
- **값과 객체의 가장 큰 차이점** : 값은 식별자를 가지지 않지만,  객체는 식별자를 가짐.
- **동등성** : 상태를 이용해 두 값이 같은지 판단할 수 있는 성질
    - 상태가 같다 → 값이 같다
- **상태를 이용해 동등성을 판단할 수 있는 이유**
    - 값의 상태는 변하지 않기 때문
- 값은 오직 상태만을 이용해 동등성을 판단하기 때문에, 인스턴스를 구별하기 위한 별도의 식별자가 필요 X
- 객체는 시간에 따라 변경되는 상태를 포함하고, 행동을 통해 상태를 변경하기 때문에 **가변 상태**를 가짐
- **동일성** : 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질
- **상태를 기반으로 객체의 동일성을 판단할 수 없는 이유**
    - 시간의 흐름에 따라 객체의 상태가 변하기 때문
    - 어느 한 시점에 두 객체의 상태가 동일하더라도, 한 객체의 상태가 변하는 순간 두 객체는 서로 다른 상태가 됨 ⇒ 따라서 상태 변경에 독립적인 별도의 식별자를 이용
- 정리
    - **값**은 **동등성 검사**를 통해 비교
    - **객체**는 **동일성 검사**를 통해 비교
- **참조 객체/엔티티** : 식별자를 지닌 객체
- **값 객체** : 식별자를 가지지 않는 값

---

### 기계로서의 객체

- **쿼리** : 객체의 상태를 **조회**하는 작업
- **명령** : 객체의 상태를 **변경**하는 작업
- 명령과 쿼리는 **객체가 외부에 제공하는 행동**
- 객체에 접근할 수 있는 유일한 방법 : 객체가 제공하는 행동

---

### 행동이 상태를 결정한다

- **상태를 결정하고 행동을 나중에 결정하는 방법이 끼치는 나쁜 영향**
    1. 상태를 먼저 결정할 경우 캡슐화가 저해됨.
    2. 객체를 협력자가 아닌 고립된 섬으로 만듦.
    3. 객체의 재사용성이 저하됨.
- 애플리케이션 안에서 **어떤 행동을 원하느냐**가 **어떤 객체가 적합한지**를 결정
- 행동을 결정해야, 행동에 필요한 정보가 무엇인지 고려하게 되고, 이 과정에서 필요한 상태가 결정됨.
- 협력 안에서 **객체의 행동**은 객체가 협력에 참여하면서 **완수해야 하는 책임**을 의미하기 때문에, 어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 함.

---

### 현실 속 객체와 소프트웨어 객체의 차이점

- 현실 속에서는 **수동적인 존재**가 소프트웨어 객체로 구현될 때는 **능동적**으로 변함.
