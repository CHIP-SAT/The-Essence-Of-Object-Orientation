### 마틴 파울러가 말하는 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점

1. **개념 관점(Conceptual Perspective)**
    - 사용자가 도메인을 바라보는 관점을 반영하기 때문에 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심
2. **명세 관점(Specification Perspective)**
    - 도메인의 개념이 아니라 실제로 소프트웨어 안에서 살아 숨 쉬는 객체들의 책임에 초점
    - 프로그래머는 객체가 협력을 위해 ‘**무엇’**을 할 수 있는가에 초점
    
    > “구현이 아니라 인터페이스에 대해 프로그래밍 하라” - GOF
    > 
3. **구현 관점(Implementation Perspective)**
    - 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것에 초점
    - 프로그래머는 객체의 책임을 ‘**어떻게**’ 수행할 것인가에 초점을 맞추며 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가함.

⇒ 개념 관점, 명세 관점, 구현 관점은 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미하지, 위 순서대로 소프트웨어를 개발한다는 의미가 아님!

- **관점 별 은유적 표현**
    - 클래스 → 도메인 관점을 반영
    - 클래스의 공용 인터페이스 → 명세 관점을 반영
    - 클래스의 속성과 메서드 → 구현 관점을 반영
- 클래스는 세 가지 관점을 모두 수용할 수 있도록 **개념**, **인터페이스**, **구현**을 함께 드러내야 함.

---

### 커피 전문점 도메인

- **현실의 복잡성을 낮추기 위해 타입으로 분류**
    - 도메인 모델을 작성하는 단계에서 어떤 관계가 포함 관계이고 어떤 관계가 연관 관계인지는 중요하지 X
        - 포함 관계: 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하는 경우
        - 연관 관계: 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하진 않지만 서로 알고 있어야 하는 경우
    - 어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악함으로써 도메인을 이해하는 것에 초점
- **설계하기**
    - 객체지향 설계의 첫 번째 목표: 훌륭한 객체를 설계하는 것이 아닌, **훌륭한 협력을 설계하는 것**
        - 훌륭한 객체는 훌륭한 협력을 설계할 때만 얻을 수 있음.
    - 메시지를 수신할 객체는 **메시지를 처리할 책임**을 맡게 되고, 객체가 수신하는 메시지는 객체가 외부에 제공하는 **공용 인터페이스**에 포함됨.
    - 소프트웨어 객체는 현실 속의 객체를 모방하거나 추상화한 것이 아닌, 단지 의미를 쉽게 유추할 수 있도록 **은유**할 뿐임.
- **인터페이스 정리하기**
    - 객체가 수신한 메시지가 객체의 인터페이스를 결정함.
    - 객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재한다는 것을 의미
        - 예시
            - 손님 객체의 인터페이스 ← ‘커피를 주문하라’
            - 메뉴판 객체의 인터페이스 ← ‘메뉴 항목을 찾아라’
    - 실제로 소프트웨어의 구현은 동적인 객체가 아닌 정적인 타입을 이용해 이뤄지기 때문에, 객체들을 포괄하는 **타입을 정의한 후** **식별된 오퍼레이션을 타입의 인터페이스에 추가**해야 함.
    - 객체의 타입을 구현하는 일반적인 방법 ⇒ **클래스** 이용
        - 협력을 통해 식별된 타입의 오퍼레이션은 외부에서 접근 가능한 공용 인터페이스의 일부이기 때문에, 공용(public)으로 선언돼 있어야 함.
- **구현하기**
    - 객체가 다른 객체에게 메시지를 전송하기 위해서는 **객체에 대한 참조**를 얻어야 함.
        - 객체에 대한 참조를 얻는 방법: 메서드의 인자로 전달받는 방법 등
    - 설계 작업은 **구현을 위한 스케치를 작성**하는 단계지 구현 그 자체일 수 없음.
    - 중요한 것은 설계가 아닌 코드이기 때문에, 협력을 구상하는 단계에 너무 오랜 시간을 쏟지 말고 최대한 빨리 코드를 구현해서 설계에 이상이 없는지, 설계가 구현 가능한지를 판단해야 함.
    - 객체에게 책임을 할당하고 인터페이스를 결정할 때는 가급적 객체 내부의 구현에 대한 어떤 가정도 하지 말아야 함.
        - 객체가 어떤 책임을 수행해야 하는지를 결정한 후에 책임을 수행하는 데 필요한 객체의 속성을 결정해야 함.

---

### 코드와 세 가지 관점

- **코드는 세 가지 관점을 모두 제공해야 함.**
- **개념 관점**
    - 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있음.
- **명세 관점**
    - 클래스의 인터페이스를 바라봄.
    - 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러냄.
    - 최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 함.
- **구현 관점**
    - 클래스의 내부 구현을 바라봄.
    - 클래스의 **메서드**와 **속성**은 공용 인터페이스의 일부가 아닌 **구현**에 속하기 때문에, 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안됨.
- **어떤 메시지가 있을 때 그 메시지를 수신할 객체를 어떻게 선택하는가?**
    - 도메인 개념 중에서 가장 적절한 것을 선택
        - 도메인 개념 안에서 적절한 객체를 선택하는 것은 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 함. ⇒ 시스템의 유지보수성에 큰 영향을 미침.
- **인터페이스와 구현을 분리하라**
    - 인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻음.
    - 명세 관점이 설계를 주도하게 하면 설계의 품질이 향상될 수 있음.
