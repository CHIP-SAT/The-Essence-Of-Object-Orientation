### 함께 모으기

##

지난 챕터에서 도메인을 배웠다. 도메인이란, 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하고 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다.

UML, 에자일을 만든 마틴 파울러는 객체지향 설계 안에 존재하는 세 가지 **상호 연관된 관점**을 설명한다. 이 때 세 관점이란 개념, 명세, 구현 관점이다.

이 관점은 하나의 클래스 하나를 보더라도, 세 관점으로 다양한 관점에서 볼 수 있다.

- **개념** 관점 (Conceptual)
  - 도메인 안에 존재하는 개념들 사이의 관계
  - 실제 도메인의 규칙과 제약을 최대한 유사하게 반영
  - **사용자가 도메인을 바라보는 관점**을 반영
- **명세** 관점 (Specification)
  - 사용자의 영역인 도메인을 벗어나, **개발자 영역인 소프트웨어**에 초점
  - 객체가 협력을 위해 '무엇'을 할 수 있는가
  - 인터페이스와 구현을 분리하는 것
- **구현** 관점 (Implementation)
  - 실제 작업을 수행하는 코드와 연관됨
  - **객체들이 책임을 '어떻게' 수행할 것인가**
  - 인터페이스를 구현하는데 필요한 속성과 메소드를 클래스에 추가하는 것

위 관점을 정리하면, 클래스가 은유하는 개념은 도메인 관점을 반영하고, 클래스의 공용 인터페이스는 명세 관점, 클래스의 속성과 메소드는 구현 관점을 반영한다.

클래스는 세 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. 코드 안에서 세 관점을 식별할 수 있게 분리 잘하기.

지금까지 우리는 역할, 책임, 협력으로 객체 인터페이스를 식별했다. 협력에 참여하기 위해 객체가 수신할 메세지를 결정하고, 그런 메세지들이 모여 인터페이스를 구성했다. 따라서 협력 안에서 메세지를 선택하고, 메세지를 수신할 객체를 선택하는 것은 인터페이스, 즉 명세 관점에서 객체를 바라보는 것이다.

지금껏 명세 관점에서 얘기했으니, 본 장에서는 개념 + 구현 관점까지 더해 살펴보며 "도메인 모델에서 시작해 최종 코드까지 구현", "구현 클래스를 개념, 명세, 구현 관점에서 바라보기"를 진행한다.

##

### 커피 전문점 도메인
![2025  8  18  18:57 Microsoft Lens](https://github.com/user-attachments/assets/cea56c43-0d31-44bc-a9f6-f7d69397720e)

객체지향의 관점에서 커피 전문점 도메인은 '손님, 메뉴항목, 메뉴판, 바리스타, 커피' 객체로 구성된 세상이다.

아메리카노, 에스프레소, ... 등의 커피류는 '커피 타입'의 인스턴스이고, 메뉴판 객체는 '메뉴판' 타입의 인스턴스이자 여러 커피 항목의 객체를 포함할 수 있다. 여기서 커피 종류는 '메뉴 항목 타입'의 인스턴스라고 또 부를 수 있다.

![2025  8  18  19:10 Microsoft Lens](https://github.com/user-attachments/assets/a9b0cd8e-9a21-4753-96ca-640d1d46802d)

속이 꽉 찬 마름모는 **포함 관계, 또는 합성 관계**를 나타낸다. 메뉴 항목이 메뉴판에 포함된다는 것으로 4개의 메뉴가 메뉴판에 포함된다는 것을 알 수 있다.

또, 손님이 메뉴판을 알아야 주문이 가능할 텐데, 이는 손님의 일부가 아니니까 합성이 아닌 서로를 알아야 하는 **연관 관계**라 부르고 일반적인 선으로 잇는다.

바리스타도 커피를 제조해야 하니까 커피 타입을 알고 있어야 하고, 메뉴판과 커피도 바리스타의 일부가 아니므로 포함관계는 아니게 된다.

위 내용은 도메인을 구성하는 타입들의 종류와 관계를 나타낸 것이고, 타입과 관계를 이용해 추상화한 일종의 모델이다. 이처럼 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 것을 도메인 모델이라 한다.

##

### 설계하고 구현하기
도메인을 단순화해서 이해했고, 이제 소프트웨어로 옮길 차례이다. 객체지향의 세계는 협력하는 자율적 객체들의 공동체이고, 이때 중요한 것은 객체들의 훌륭한 협력 설계이다.

협력을 설계할 때는 메세지가 객체를 선택하게 해야 한다. 다시 말하면 메세지를 먼저 선택하고, 그 후에 메세지를 수신하기에 적절한 객체를 선택해야 함을 의미한다.

그러면 메세지를 수신할 객체는 메세지를 처리할 책임을 갖게 되고, 객체가 수신하는 메세지는 객체가 외부에 제공하는 공용 인터페이스에 포함된다.

<br>

#### 커피를 주문하기 위한 협력 찾기
커피를 주문하는 협력에서의 메세지는 "커피를 주문하라"이다. 이때 메뉴 이름을 포함하여 커피를 주문하게 될 것이다.

메세지를 정했으니 이를 책임질 객체를 찾으면 손님이 있고, 따라서 손님이 커피 주문에 대한 책임을 할당받게 된다.

메뉴 이름을 포함한 커피 주문하기를 손님이 수행해야 하는데, 메뉴 이름을 손님이 알지는 못 한다. 따라서 손님은 외부로 전송되는 메세지를 만들어 다른 객체에게 요청해야 한다.

메뉴를 잘 알고 있는 메뉴판 객체는 메뉴를 알려주는 메세지를 갖게되고 이에 맞는 책임을 가지게 된다. (현실 세계와 객체지향 세계의 차이점이다. 현실 세계에선 메뉴판 혼자 메뉴를 찾지 못하지만 객체지향에서 객체는 모두 능동적이다)

이제 손님은 메뉴판으로부터 메뉴를 받아와 커피를 요청할 수 있게 됐다.

<br>

![2025  8  18  19:37 Microsoft Lens](https://github.com/user-attachments/assets/c5036c60-f5b9-4c44-85a4-3cac6b1a2a5b)

커피를 제조하라는 메세지는 바리스타가 책임을 질 것이고, 바리스타는 커피 제조법을 알고 있기에 스스로 판단과 지식에 따라 행동하는 자율적 존재가 될 수 있다.

그리고 만들어진 이 커피 반환값을 손님이 받게 될 것이다.

<br>

#### 인터페이스 정리하기
객체가 수신한 메세지가 객체의 인터페이스를 결정한다고 앞에서 배웠다. 메세지가 객체를 선택했고, 선택된 객체는 메세지를 자신의 인터페이스로 받아들인다.

객체의 협력은 런타임 시점에 발생하는 동적 모델이지만, 우리는 실제 구현할 때 정적 타입을 이용해 개발한다.

따라서 객체들을 포괄하는 타입을 정하고, 식별된 오퍼레이션(= 역할)을 타입의 인터페이스에 추가해야 한다.

객체 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다. 이후 오퍼레이션을 수행하는 메소드를 구현하며 최종 구현까지 나아가면 된다.

<br>

구현하지 않고, 머릿속으로만 설계하다보면 코드 구현 단계에서 대부분 변경된다. 중요한 것은 설계가 아니라 코드이다.

따라서 협력을 구상하는데 너무 시간을 쏟지말고, 코드를 통해 피드백을 받으며 설계에 대한 판단을 해야 한다.

![2025  8  18  20:18 Microsoft Lens](https://github.com/user-attachments/assets/d0cde20b-3cbc-42bb-9beb-8f16d2c4bfbb)

완성된 커피 전문점 도메인의 클래스 다이어그램이다.

##

### 코드와 세 가지 관점
#### 코드는 세 가지 관점을 모두 제공해야 한다.
이번 장 초반에서 클래스는 세 가지 관점(개념, 명세, 구현)을 모두 제공해야 한다고 했다.

개념 관점에서 코드를 보면, Customer, Menu, MenuItem... 등의 클래스가 보인다. 이 클래스는 커피 전문점 도메인을 구성하는 중요한 개념과 관계를 반영한다는 것을 알 수 있다. 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고, 유지보수성을 향상시킬 수 있다.

명세 관점은 클래스의 인터페이스에서 보이는데, 클래스의 public 메소드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다. 공용 인터페이스는 수정하기가 어려운데, 이는 해당 객체와 협력하는 모든 객체에 영향이 가기 때문이다. 최대한 변화에 안정적으로 하려면 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.

구현 관점은 클래스의 내부 구현을 바라보는데, 클래스 안에 있는 메소드와 속성과 같은 구현체를 의미한다. 구현체는 이론 상 변경됐을 때 다른 애들에게 영향을 미쳐서 안되는데, 클래스 내부에 캡슐화돼야 하기 때문이다.

위 세 관점은 동일한 코드를 바라보고 있지만, 서로 다른 관점이다. 훌륭한 객체지향 개발자는 하나의 클래스 안에 세 가지 관점을 모두 포함하면서도 각 관점에 대응되는 요소를 명확하고 깔끔하게 드러낼 수 있다.

이 관점을 명확히 드러내게 해서 변경에 유연하게 대응할 수 있는 객체지향 코드 ㄱㄱ

<br>

#### 도메인 개념을 참조하는 이유
어떤 메세지가 있을 때 수신할 객체 선정을 어떻게 하는 게 좋은지에 대한 내용이다.

도메인 개념 중에서 가장 적절한 것을 선택하는 게 좋은데, 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 하여 유지보수성을 키울 수 있다.

소프트웨어는 항상 변경되기에 이에 대응할 수 있도록 소프트웨어 클래스가 도메인 개념을 따르도록 한다.

<br>

#### 인터페이스와 구현 분리
명세 관점은 클래스의 안정적인 측면, 구현 관점은 클래스의 불안정한 측면을 드러내야 한다.

인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻을 수 밖에 없다.

캡슐화를 위반해서 구현을 인터페이스 밖으로 노출해도 안되고, 인터페이스와 구현 분리를 대충해도 안 된다.
