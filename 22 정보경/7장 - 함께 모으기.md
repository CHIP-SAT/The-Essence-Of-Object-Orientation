## 커피 전문점 도메인 209p~

### 커피 주문

커피 제조 예제

손님이 메뉴판을 본 후 커피를 주문

주문받은 커피를 제조하는 것은 바리스타의 몫

### 커피 전문점이라는 세상

커피 전문점이라는 도메인은 손님 객체, 메뉴 항목 객체, 메뉴판 객체, 바리스타 객체, 커피 객체로 구성된 작은 세상

- 객체들 간의 관계
    
    손님과 메뉴판, 손님과 바리스타, 바리스타와 자신이 제조한 커피
    

동적인 객체를 정적인 타입으로 추상화하여 복잡성을 낮춘다. (타입은 분류를 위해 사용된다)

커피 전문점을 구성하는 범주로서 손님 타입, 메뉴판 타입, 메뉴 항목 타입, 바리스타 타입, 커피 타입

- 타입 간의 관계
    
    메뉴판 타입과 메뉴 항목 타입 간의 **합성(composition, 또는 포함) 관계**
    
    메뉴판 타입은 손님의 일부가 아니므로 합성 관계는 아님
    
    → 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 할 경우 **연관(association) 관계** 라고 함
    
    ![image.png](attachment:4ffc20a9-1fdd-452e-9bce-1be1f310ead4:image.png)
    
    참고: 도메인 모델을 작성하는 단계에서 어떤 관계가 포함 관계이고 어떤 관계가 연관 관계인지는 중요하지 않음. 관계가 존재한다는 사실을 이해하는 것만으로도 충분
    

## 설계하고 구현하기 214p~

### 커피를 주문하기 위한 협력 찾기

객체지향 설계의 첫 번째 목표는 훌륭한 객체를 설계하는 것이 아니라 훌륭한 협력을 설계하는 것

- 커피를 주문하는 협력 설계
    
    첫 번째 메시지: ‘커피를 주문하라’
    
    ![image.png](attachment:6b240ae7-549a-483b-9d73-cfb74dd584a9:image.png)
    
    → 메시지 위에 붙은 화살표는 인자를 의미(’아메리카노를 주문하라’ ⇒ ‘커피를 주문하라(아메리카노)’
    
    메시지를 찾았으니 메시지를 처리하기에 적합한 객체를 선택해야 함
    
    → 도메인 모델 안에 책임을 수행하기에 적절한 타입이 존재하는지 확인
    
    → 적절한 타입을 발견했다면 책임을 수행할 객체를 그 타입의 인스턴스로 만들기
    
    ‘커피를 주문하라’라는 메시지를 처리할 객체는 손님 타입의 인스턴스
    
    ![image.png](attachment:0d556be6-c04a-4e96-a0e1-ab76b981ad56:image.png)
    
    손님이 커피를 주문하는 도중에 스스로 할 수 없는 일
    
    → 메뉴 항목에 대해 알지 못함
    
    → 메뉴 항목을 제공해 줄 것을 요청
    
    → ‘메뉴 항목을 찾아라’ 라는 새로운 메시지의 등장
    
    ![image.png](attachment:f6f42b61-d460-450b-80e3-207464403c53:image.png)
    
    메뉴 항목을 잘 알고 있는 객체는 메뉴판 객체
    
    ![image.png](attachment:be7aaadd-6175-481d-8555-cc40f0903686:image.png)
    
    중략
    
    ![image.png](attachment:5af5a8c2-254b-484d-af87-fa948036baaf:image.png)
    

### 인터페이스 정리하기

객체가 수신한 메시지가 객체의 인터페이스를 결정

각 객체를 협력이라는 문맥에서 떼어내어 수신 가능한 메시지만 추려내면 객체의 인터페이스가 된다.

객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재한다는 것을 의미

→ 손님 객체의 인터페이스 안에는 ‘커피를 주문하라’라는 오퍼레이션이 포함

인터페이스에 포함된 오퍼레이션은 외부에서 접근 가능하도록 공용(public)으로 선언돼 있어야 한다.

### 구현하기

객체 참조를 얻는 다양한 방법이 있지만 여기서는 인자로 전달 받는 방법으로 참조 문제 해결

→ 구현 도중에 인터페이스가 변경될 수 있음

설계 작업은 구현을 위한 스케치를 작성하는 단계지 구현 그 자체일 수는 없다. 중요한 것은 설계가 아니라 코드다. 따라서 협력을 구상하는 단계에 너무 오랜 시간을 쏟지 말고 최대한 빨리 코드를 구현해서 설계에 이상이 없는지, 설계가 구현 가능한지를 판단해야 한다. 코드를 통한 피드백 없이는 깔끔할 설계를 얻을 수 없다.

객체에게 책임을 할당하고 인터페이스를 결정할 때는 가급적 객체 내부 구현에 대한 어떤 가정도 하지 말아야 한다. 객체가 어떤 책임을 수행해야 하는지를 결정한 후에야 책임을 수행하는 데 필요한 객체의 속성을 결정하라.

테스트-주도 설계로 코드를 구현하는 사람들은 테스트 코드를 작성해 가면서 협력을 설계한다.

## 코드와 세 가지 관점 226p~

### 코드는 세 가지 관점을 모두 제공해야 한다

- 개념 관점 - 클래스 보기
    
    소프트웨어 클래스와 도메인 클래스 사이의 간격이 좁으면 좁을수록 기능을 변경하기 위해 뒤적거려야 하는 코드의 양도 점점 줄어든다.
    
- 명세 관점 - 클래스의 인터페이스 보기
    
    객체의 인터페이스는 수정하기 어렵다.
    
    → 최대한 변화에 안정적인 인터페이스를 만들기 위해 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 함
    
- 구현 관점 - 클래스의 내부 구현 보기
    
    클래스의 메서드와 속성은 구현에 속하며 공용 인터페이스의 일부가 아니다.
    
    → 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안 된다.
    
    → 메서드와 속성이 클래스 내부로 캡슐화
    

세 가지 관점이 명확하게 드러날 수 있게 코드를 개선하라. 그것이 변경에 유연하게 대응할 수 있는 객체지향 코드를 작성하는 가장 빠른 길이다.

### 도메인 개념을 참조하는 이유

어떤 메시지가 있을 때 그 메시지를 수신할 객체를 어떻게 선택하는가?

→ 첫 번째 전략은 도메인 개념 중에서 가장 적절한 것을 선택하는 것

→ 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 함

→ 시스템의 유지보수성

→ 변화에 쉽게 대응할 수 있다.

### 인터페이스와 구현을 분리하라

명세 관점은 클래스의 안정적인 측면을 드러내야 하고, 구현 관점은 클래스의 불안정한 측면을 드러내야 함

마틴 파울러는 개념적인 관점과 명세 관점 사이는 그렇게 중요하지 않은 경우가 많지만, 명세 관점과 구현 관점을 분리하는 것은 매우 중요하다고 주장

훌륭한 설계를 결정하는 측면은 명세 관점인 객체의 인터페이스

클래스를 봤을 때 명세 관점과 구현 관점으로 나눠볼 수 있어야 함
