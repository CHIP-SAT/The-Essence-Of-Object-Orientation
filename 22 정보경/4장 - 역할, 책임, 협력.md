## 협력 110p~

### 요청하고 응답하며 협력하는 사람들

**협력**은 한 사람이 다른 사람에게 도움을 **요청**할 때 시작된다. 요청을 받은 사람은 일을 처리한 후 요청한 사람에게 필요한 지식이나 서비스를 제공하는 것으로 요청에 **응답**한다.

→ 협력은 다수의 요청과 응답으로 구성되며 전체적으로 협력은 다수의 연쇄적인 요청과 응답의 흐름으로 구성된다.

### 누가 파이를 훔쳤지?

앨리스에서 파이를 훔친 하트 잭에 대한 재판 장면 설명

모자 장수가 증인하는 모습까지 보여줌

### 재판 속의 협력

하트 잭을 재판하기 위해 등장인물들은 협력함

- 왕이 모자 장수로부터 증언을 듣는 과정
    - 누군가가 왕에게 재판을 **요청**함으로써 재판이 시작된다.
        
        → 왕이 재판을 수행할 의무가 있으며, 재판에 필요한 지식을 가지고 있음
        
    - 왕이 하얀 토끼에게 증인을 부를 것을 **요청**한다.
        
        → 토끼가 목격자에 대해 알고 있으며, 동시에 목격자를 부를 의무가 있음
        
    - 왕의 요청을 받은 토끼는 모자 장수에게 증인석으로 입장할 것을 **요청**한다.
    - 모자 장수는 증인석에 입장함으로써 토끼의 요청에 **응답**한다.
    - 모자 장수의 입장은 왕이 토끼에게 요청했던 증인 호출에 대한 **응답**이기도 하다.
    - 이제 왕은 모자장수에게 증언할 것을 **요청**한다.
        
        → 모자 장수가 재판에 도움이 될 만한 사건의 내용에 대해 조금이라도 알고 있으며 증언할 의무가 있기 때문
        
    - 모자 장수는 자신이 알고 있는 내용을 증언함으로써 왕의 **요청**에 응답한다.

→ 등장인물들이 특정한 요청을 받아들일 수 있는 이유는 그 요청에 대해 적절한 방식으로 응답하는 데 필요한 지식과 행동 방식을 가지고 있기 때문이다.

요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.

## 책임 114p~

어떤 대상에 대한 요청은 그 대상이 요청을 처리할 책임이 있음을 암시

“객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것” - 크레이그 라만

책임을 어떻게 구현할 것인가 하는 문제는 객체와 책임이 제자리를 잡은 후에 고려해도 늦지 않다.

→ 성급하게 구현하면 변경에 취약하고 다양한 협력에 참여할 수 없는 비자율적인 객체를 낳게 된다.

### 책임의 분류

객체의 책임은 ‘객체가 무엇을 알고 있는가(knowing)’와 무엇을 할 수 있는가(doing)’로 구성된다.

크레이그 라만의 객체의 책임의 두 범주

- 하는 것(doing)
    - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것(knowing)
    - 개인적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 잇는 것에 관해 아는 것

→ 앨리스 비유

- 왕
    - 토끼에게 목격자를 불러오도록 하고, 모자 장수에게 증언 요청
        
        다른 객체들의 활동을 제어하고 조율 → 하는 것
        
- 토끼
    - 목격자가 모자 장수라는 것을 알고 있음
        
        관련된 객체에 대해 아는 것 → 아는 것
        
    - 모자 장수가 증인석에 입장하도록 요청
        
        다른 객체의 행동을 시작시키는 것 → 하는 것
        
- 모자 장수
    - 스스로 증인석에 입장해야 하는 책임
        
        객체를 생성하거나 계산을 하는 등의 스스로 하는 것 → 하는 것
        
    - 자신이 알고 있는 사실을 증언해야 할 책임
        
        자신이 유도하거나 계산할 수 있는 것에 관해 아는 것 → 아는 것
        

책임을 적절히 명확하게 할당할 것 강조

책임은 객체의 외부에 제공해줄 수 있는 정보와 서비스의 목록

→ 책임은 객체의 공용 인터페이스를 구성한다 → 캡슐화로 이어짐

### 책임과 메시지

협력 안에서 객체는 다른 객체로부터 요청이 전송됐을 경우에만 자신에게 주어진 책임을 수행한다.

→ 한 객체가 다른 객체에게 전송한 요청은 그 요청을 수신한 객체의 책임이 수행되게 한다.

객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 **메시지 전송**이라고 한다.

책임과 메시지의 수준이 같지는 않다.

→ 책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것

→ 챇임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적

책임과 메시지에 대한 윤곽을 먼저 잡은 뒤 나머지를 생각하라는 거 또 강조

## 역할 119p~

### 책임의 집합이 의미하는 것

어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다.

→ 왜 중요한가?

→ 역할이 재사용 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소이기 때문이다.

### 판사와 증인

모자 장수가 퇴장하는 장면부터 앨리스가 증인으로 불리는 장면까지의 앨리스 내용

- 앞선 이야기와 지금 이야기의 비교
    - 차이점
        
        모자 장수 대신 요리사와 앨리스가 재판의 증인이 되고, 왕 대신 여왕에게 자신의 일을 위임했다는 점
        
    - 유사점
        
        재판 과정의 흐름
        

### 역할이 답이다

세 개의 협력이 주어져있는데, 등장인물을 제외한 나머지 과정이 유사하여 하나의 협력으로 다루고 싶음

→ 역할을 사용하면 하나의 협력으로 추상화할 수 있다.

역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다.

협력 안에서 역할은 “이 자리는 해당 역할을 수행할 수 있는 어떤 객체라도 대신할 수 있습니다” 라고 말하는 것과 같다.

아무 객체나 역할을 대체할 수 있는 것은 아니고, 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해해야 한다.

→ 역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정

메시지는 책임을 의미한다. 또 강조

동일한 역할을 수행하는 객체들이 동일한 메시지를 수신할 수 있기 때문에 동일한 책임을 수행할 수 있다.

역할은 객체지향 설계의 **단순성**, **유연성**, **재사용성**을 뒷받침함

### 협력의 추상화

역할의 가장 큰 가치는 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다는 것

→ 협력의 개수를 줄이고, 구체적인 객체를 추상적인 역할로 대체함으로써 협력의 양상을 단순화

→ 애플리케이션의 설계를 이해하고 기억하기 쉬워진다

### 대체 가능성

역할은 다른 객체에 의해 대체 가능함을 의미한다.

객체가 역할을 대체하기 위해서는 행동이 호환되야 한다.

객체가 역할에 주어진 책임 이외에 다른 책임을 수행할 수도 있다.

→ 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다.

→ 역할은 일반화, 객체의 타입은 특수화

역할의 대체 가능성 → 행위 호환성 → 동일한 책임의 수행

## 객체의 모양을 결정하는 협력 128p~

### 흔한 오류

- 객체지향에 대한 선입견
    1. 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다
        
        → 객체는 행위를 수행하며 협력에 참여하기 위해 존재
        
    2. 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다
        
        → 중요한 것은 정적인 클래가 아니라 협력에 참여하는 동적인 객체
        

객체를 설계할 때 협력이라는 문맥에서 하라는 거 또 강조

### 협력을 따라 흐르는 객체의 책임

올바를 객체를 설계하기 위해서는 견고하고 깔끔한 협력을 설계해야 한다.

→ 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정한다. → 책임

협력이라는 문맥에서 객체가 수행하게 될 적절한 책임, 즉 행동을 결정한 후에 그 행동을 수행하는 데 필요한 데이터를 고민해야 한다.

협력에 참여하기 위해 필요한 데이터와 행동이 어느 정도 결정 된 후에 클래스의 구현 방법을 결정해야 한다.

객체를 충분히 협력적으로 만든 후에 협력이라는 문맥 안에서 객체를 충분히 자율적으로 만드는 것이다.

## 객체지향 설계 기법 130p~

1. **책임-주도 설계(Responsibility-Driven Design)** 방법은 협력에 필요한 책임들을 식별하고 적합한 객체에 책임을 할당하는 방식
2. **디자인 패턴(Design Pattern)**은 전문가들이 반복적으로 사용하는 해결 방법을 정의해놓은 설계 템플릿의 모음
3. 테스트 주도 개발(Test-Driven Development)은 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식

### 책임-주도 설계

객체지향 설계란 애플리케이션의 기능을 구현하기 위한 협력 관계를 고안하고, 협력에 필요한 역할과 책임을 식별한 후 이를 수행할 수 있는 적절한 객체를 식별해 나가는 과정이다.

객체지향 설계의 핵심은 올바른 책임을 올바른 객체에 할당하는 것이다.

책임-주도 설계 방법은 객체의 책임을 중심으로 시스템을 구축하는 설계 방법

시스템의 책임을 객체의 책임으로 변환하고, 각 객체가 책임을 수행하는 중에 필요한 정보나 서비스를 제공해줄 협력자를 찾아 해당 협력자에게 책임을 할당하는 순차적인 방식으로 객체들의 협력 공동체를 구축한다.

- 요약
    - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
    - 시스템 책임을 더 작은 책임으로 분할한다.
    - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
    - 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
    - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

### 디자인 패턴

책임-주도 설계는 객체의 역할, 책임, 협력을 고안하기 위한 방법과 절차를 제시

디자인 패턴은 책임-주도 설계의 결과를 표현

패턴은 특정한 상황에서 설계를 돕기 위해 모방하고 수정할 수 있는 과거의 설계 경험이다.

디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의

반복해서 일어나는 특정한 상황에서 어떤 설계가 왜 더 효과적인지에 대한 이유를 설명한다.

- Composite 패턴
    
    전체와 부분을 하나의 단위로 추상화해야 하는 경우에 사용할 수 있는 패턴
    
    클라이언트 입장에서 메시지 수신자가 부분(파일)인지 전체(폴더)인지 상관없이 동일한 메시지(경로 변경)를 이용해 동일한 방식으로 대상과 상호작용
    
    그림에 표현돼 있는 구성 요소가 클래스와 메서드가 아니라 ‘협력’에 참여하는 ‘역할’과 ‘책임’이다.
    

Composite 패턴은 부분가 전체가 투명하고 동일한 인터페이스를 제공해야 한다는 제약 하에서 식별된 역할, 책임, 협력을 제공하는 한 가지 설계 예제다.

→ 책임-주도 설계의 결과물이라고 할 수 있다.

### 테스트-주도 개발

애자일 방법론의 한 종류인 XP의 기본 프랙티스로 소개되면서 주목받기 시작한 설계 기법

실패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작성한 후, 리팩터링을 통해 중복을 제거하는 것이다.

→ 작동하는 깔끔한 코드를 얻을 수 있다.

책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.

테스트-주도 개발은 다양한 설계 경험과 패턴에 대한 지식이 없는 사람들의 경우 온전한 혜택을 누리기는 어렵다.

- 객체지향에 대한 깊이 있는 지식을 요구하는 테스트-주도 개발
    
    테스트를 작성하기 위해 객체의 메서드를 호출하고 반환값을 검증하는 것은, 순간적으로 객체가 수행해야 하는 책임에 관해 생각한 것이다.
    
    테스트에 필요한 간접 입력 값을 제공하기 위해 스텁을 추가하거나 간접 출력 값을 검증하기 위해 목 객체를 사용하는 것은 객체와 협력해야 하는 협력자에 관해 고민할 결과를 코드로 표현한 것이다.
